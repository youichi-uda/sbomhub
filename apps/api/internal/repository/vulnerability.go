package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sbomhub/sbomhub/internal/model"
)

type VulnerabilityRepository struct {
	db *sql.DB
}

func NewVulnerabilityRepository(db *sql.DB) *VulnerabilityRepository {
	return &VulnerabilityRepository{db: db}
}

func (r *VulnerabilityRepository) Create(ctx context.Context, v *model.Vulnerability) error {
	query := `
		INSERT INTO vulnerabilities (id, cve_id, description, severity, cvss_score, source, published_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
		ON CONFLICT (cve_id) DO UPDATE SET
			description = EXCLUDED.description,
			severity = EXCLUDED.severity,
			cvss_score = EXCLUDED.cvss_score,
			source = EXCLUDED.source,
			updated_at = EXCLUDED.updated_at
	`
	_, err := r.db.ExecContext(ctx, query, v.ID, v.CVEID, v.Description, v.Severity, v.CVSSScore, v.Source, v.PublishedAt, v.UpdatedAt)
	return err
}

func (r *VulnerabilityRepository) GetByCVE(ctx context.Context, cveID string) (*model.Vulnerability, error) {
	query := `SELECT id, cve_id, description, severity, cvss_score, source, published_at, updated_at FROM vulnerabilities WHERE cve_id = $1`
	var v model.Vulnerability
	err := r.db.QueryRowContext(ctx, query, cveID).Scan(&v.ID, &v.CVEID, &v.Description, &v.Severity, &v.CVSSScore, &v.Source, &v.PublishedAt, &v.UpdatedAt)
	if err != nil {
		return nil, err
	}
	return &v, nil
}

// GetByCVEID is an alias for GetByCVE (used by JVN service)
func (r *VulnerabilityRepository) GetByCVEID(ctx context.Context, cveID string) (*model.Vulnerability, error) {
	return r.GetByCVE(ctx, cveID)
}

// LinkToComponent links a vulnerability to a component (alias for LinkComponent)
func (r *VulnerabilityRepository) LinkToComponent(ctx context.Context, vulnID, componentID uuid.UUID) error {
	return r.LinkComponent(ctx, componentID, vulnID)
}

func (r *VulnerabilityRepository) LinkComponent(ctx context.Context, componentID, vulnID uuid.UUID) error {
	query := `
		INSERT INTO component_vulnerabilities (component_id, vulnerability_id, detected_at)
		VALUES ($1, $2, NOW())
		ON CONFLICT (component_id, vulnerability_id) DO NOTHING
	`
	_, err := r.db.ExecContext(ctx, query, componentID, vulnID)
	return err
}

func (r *VulnerabilityRepository) ListByProject(ctx context.Context, projectID uuid.UUID) ([]model.Vulnerability, error) {
	query := `
		SELECT DISTINCT v.id, v.cve_id, v.description, v.severity, v.cvss_score, COALESCE(v.source, 'NVD'), v.published_at, v.updated_at
		FROM vulnerabilities v
		JOIN component_vulnerabilities cv ON cv.vulnerability_id = v.id
		JOIN components c ON c.id = cv.component_id
		JOIN sboms s ON s.id = c.sbom_id
		WHERE s.project_id = $1
		ORDER BY v.cvss_score DESC
	`
	rows, err := r.db.QueryContext(ctx, query, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var vulns []model.Vulnerability
	for rows.Next() {
		var v model.Vulnerability
		if err := rows.Scan(&v.ID, &v.CVEID, &v.Description, &v.Severity, &v.CVSSScore, &v.Source, &v.PublishedAt, &v.UpdatedAt); err != nil {
			return nil, err
		}
		vulns = append(vulns, v)
	}
	return vulns, nil
}

func (r *VulnerabilityRepository) CountBySeverity(ctx context.Context, projectID uuid.UUID) (map[string]int, error) {
	query := `
		SELECT v.severity, COUNT(DISTINCT v.id)
		FROM vulnerabilities v
		JOIN component_vulnerabilities cv ON cv.vulnerability_id = v.id
		JOIN components c ON c.id = cv.component_id
		JOIN sboms s ON s.id = c.sbom_id
		WHERE s.project_id = $1
		GROUP BY v.severity
	`
	rows, err := r.db.QueryContext(ctx, query, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	counts := make(map[string]int)
	for rows.Next() {
		var severity string
		var count int
		if err := rows.Scan(&severity, &count); err != nil {
			return nil, err
		}
		counts[severity] = count
	}
	return counts, nil
}

// UpdateEPSSScores updates EPSS scores for vulnerabilities
func (r *VulnerabilityRepository) UpdateEPSSScores(ctx context.Context, scores map[string]EPSSData) error {
	query := `
		UPDATE vulnerabilities
		SET epss_score = $1, epss_percentile = $2, epss_updated_at = NOW()
		WHERE cve_id = $3
	`
	for cveID, data := range scores {
		_, err := r.db.ExecContext(ctx, query, data.Score, data.Percentile, cveID)
		if err != nil {
			return err
		}
	}
	return nil
}

// EPSSData holds EPSS score data
type EPSSData struct {
	Score      float64
	Percentile float64
}

// GetAllCVEIDs returns all CVE IDs in the database
func (r *VulnerabilityRepository) GetAllCVEIDs(ctx context.Context) ([]string, error) {
	query := `SELECT DISTINCT cve_id FROM vulnerabilities ORDER BY cve_id`
	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var cveIDs []string
	for rows.Next() {
		var cveID string
		if err := rows.Scan(&cveID); err != nil {
			return nil, err
		}
		cveIDs = append(cveIDs, cveID)
	}
	return cveIDs, rows.Err()
}

// GetByID retrieves a vulnerability by its UUID
func (r *VulnerabilityRepository) GetByID(ctx context.Context, id uuid.UUID) (*model.Vulnerability, error) {
	query := `
		SELECT id, cve_id, description, severity, cvss_score,
		       epss_score, epss_percentile, epss_updated_at,
		       COALESCE(source, 'NVD'), published_at, updated_at
		FROM vulnerabilities WHERE id = $1
	`
	var v model.Vulnerability
	var epssScore, epssPercentile sql.NullFloat64
	var epssUpdatedAt sql.NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&v.ID, &v.CVEID, &v.Description, &v.Severity, &v.CVSSScore,
		&epssScore, &epssPercentile, &epssUpdatedAt,
		&v.Source, &v.PublishedAt, &v.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}
	if epssScore.Valid {
		v.EPSSScore = &epssScore.Float64
	}
	if epssPercentile.Valid {
		v.EPSSPercentile = &epssPercentile.Float64
	}
	if epssUpdatedAt.Valid {
		v.EPSSUpdatedAt = &epssUpdatedAt.Time
	}
	return &v, nil
}
