package scheduler

import (
	"context"
	"database/sql"
	"log/slog"
	"time"

	"github.com/google/uuid"
)

// VulnerabilityScanJob handles scheduled vulnerability scanning
type VulnerabilityScanJob struct {
	db *sql.DB
}

// NewVulnerabilityScanJob creates a new vulnerability scan job
func NewVulnerabilityScanJob(db *sql.DB) *VulnerabilityScanJob {
	return &VulnerabilityScanJob{db: db}
}

// Run executes the vulnerability scan for all tenants with enabled scanning
func (j *VulnerabilityScanJob) Run(ctx context.Context) error {
	slog.Info("starting scheduled vulnerability scan")

	// Get all tenants with enabled scanning that are due for a scan
	tenants, err := j.getTenantsForScan(ctx)
	if err != nil {
		return err
	}

	slog.Info("found tenants for scanning", "count", len(tenants))

	for _, tenantID := range tenants {
		if err := j.scanTenant(ctx, tenantID); err != nil {
			slog.Error("failed to scan tenant", "tenant_id", tenantID, "error", err)
			continue
		}
	}

	return nil
}

func (j *VulnerabilityScanJob) getTenantsForScan(ctx context.Context) ([]uuid.UUID, error) {
	query := `
		SELECT tenant_id FROM scan_settings 
		WHERE enabled = true 
		AND (next_scan_at IS NULL OR next_scan_at <= NOW())
	`

	rows, err := j.db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var tenants []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			continue
		}
		tenants = append(tenants, id)
	}

	return tenants, nil
}

func (j *VulnerabilityScanJob) scanTenant(ctx context.Context, tenantID uuid.UUID) error {
	// Create scan log entry
	scanLogID := uuid.New()
	_, err := j.db.ExecContext(ctx, `
		INSERT INTO scan_logs (id, tenant_id, started_at, status)
		VALUES ($1, $2, NOW(), 'running')
	`, scanLogID, tenantID)
	if err != nil {
		return err
	}

	var projectsScanned, newVulns int
	var scanError error

	// Get all projects for this tenant
	projects, err := j.getProjects(ctx, tenantID)
	if err != nil {
		scanError = err
	} else {
		for _, projectID := range projects {
			vulns, err := j.scanProject(ctx, projectID)
			if err != nil {
				slog.Error("failed to scan project", "project_id", projectID, "error", err)
				continue
			}
			projectsScanned++
			newVulns += vulns
		}
	}

	// Update scan log
	status := "completed"
	errorMsg := ""
	if scanError != nil {
		status = "failed"
		errorMsg = scanError.Error()
	}

	_, err = j.db.ExecContext(ctx, `
		UPDATE scan_logs 
		SET completed_at = NOW(), 
		    status = $1, 
		    projects_scanned = $2, 
		    new_vulnerabilities = $3,
		    error_message = NULLIF($4, '')
		WHERE id = $5
	`, status, projectsScanned, newVulns, errorMsg, scanLogID)
	if err != nil {
		slog.Error("failed to update scan log", "error", err)
	}

	// Update next scan time
	if err := j.updateNextScan(ctx, tenantID); err != nil {
		slog.Error("failed to update next scan time", "error", err)
	}

	// Send notifications if new vulnerabilities found
	if newVulns > 0 {
		j.sendNotifications(ctx, tenantID, newVulns)
	}

	slog.Info("tenant scan completed", 
		"tenant_id", tenantID, 
		"projects_scanned", projectsScanned,
		"new_vulnerabilities", newVulns)

	return nil
}

func (j *VulnerabilityScanJob) getProjects(ctx context.Context, tenantID uuid.UUID) ([]uuid.UUID, error) {
	query := `SELECT id FROM projects WHERE tenant_id = $1`

	rows, err := j.db.QueryContext(ctx, query, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var projects []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			continue
		}
		projects = append(projects, id)
	}

	return projects, nil
}

func (j *VulnerabilityScanJob) scanProject(ctx context.Context, projectID uuid.UUID) (int, error) {
	// Get the latest SBOM for this project
	var sbomID uuid.UUID
	err := j.db.QueryRowContext(ctx, `
		SELECT id FROM sboms 
		WHERE project_id = $1 
		ORDER BY created_at DESC 
		LIMIT 1
	`, projectID).Scan(&sbomID)
	if err != nil {
		if err == sql.ErrNoRows {
			return 0, nil // No SBOM, nothing to scan
		}
		return 0, err
	}

	// Get components for this SBOM
	components, err := j.getComponents(ctx, sbomID)
	if err != nil {
		return 0, err
	}

	// For each component, check for new vulnerabilities
	// This is a placeholder - in production, you'd call NVD/OSV APIs
	newVulns := 0
	for _, comp := range components {
		vulns, err := j.checkComponentVulnerabilities(ctx, sbomID, comp)
		if err != nil {
			slog.Error("failed to check component", "component", comp.Name, "error", err)
			continue
		}
		newVulns += vulns
	}

	return newVulns, nil
}

type componentInfo struct {
	ID      uuid.UUID
	Name    string
	Version string
	Purl    string
}

func (j *VulnerabilityScanJob) getComponents(ctx context.Context, sbomID uuid.UUID) ([]componentInfo, error) {
	query := `SELECT id, name, version, COALESCE(purl, '') FROM components WHERE sbom_id = $1`

	rows, err := j.db.QueryContext(ctx, query, sbomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var components []componentInfo
	for rows.Next() {
		var c componentInfo
		if err := rows.Scan(&c.ID, &c.Name, &c.Version, &c.Purl); err != nil {
			continue
		}
		components = append(components, c)
	}

	return components, nil
}

func (j *VulnerabilityScanJob) checkComponentVulnerabilities(ctx context.Context, sbomID uuid.UUID, comp componentInfo) (int, error) {
	// Placeholder for actual vulnerability checking
	// In production, this would:
	// 1. Query NVD/OSV for vulnerabilities affecting this component
	// 2. Check if we already have these vulnerabilities recorded
	// 3. Insert new vulnerabilities and return the count

	// For now, return 0 (no new vulnerabilities found in this scan)
	return 0, nil
}

func (j *VulnerabilityScanJob) updateNextScan(ctx context.Context, tenantID uuid.UUID) error {
	// Get scan settings
	var scheduleType string
	var scheduleHour int
	var scheduleDay sql.NullInt64

	err := j.db.QueryRowContext(ctx, `
		SELECT schedule_type, schedule_hour, schedule_day 
		FROM scan_settings 
		WHERE tenant_id = $1
	`, tenantID).Scan(&scheduleType, &scheduleHour, &scheduleDay)
	if err != nil {
		return err
	}

	// Calculate next scan time
	now := time.Now()
	var nextScan time.Time

	switch scheduleType {
	case "hourly":
		nextScan = now.Add(1 * time.Hour).Truncate(time.Hour)
	case "daily":
		nextScan = time.Date(now.Year(), now.Month(), now.Day()+1, scheduleHour, 0, 0, 0, now.Location())
	case "weekly":
		daysUntilNext := (7 + int(scheduleDay.Int64) - int(now.Weekday())) % 7
		if daysUntilNext == 0 && now.Hour() >= scheduleHour {
			daysUntilNext = 7
		}
		nextScan = time.Date(now.Year(), now.Month(), now.Day()+daysUntilNext, scheduleHour, 0, 0, 0, now.Location())
	default:
		nextScan = now.Add(24 * time.Hour)
	}

	_, err = j.db.ExecContext(ctx, `
		UPDATE scan_settings 
		SET last_scan_at = NOW(), next_scan_at = $1, updated_at = NOW()
		WHERE tenant_id = $2
	`, nextScan, tenantID)

	return err
}

func (j *VulnerabilityScanJob) sendNotifications(ctx context.Context, tenantID uuid.UUID, newVulns int) {
	// Get notification settings and send alerts
	// This is a placeholder - would integrate with the existing notification service
	slog.Info("sending vulnerability notifications", "tenant_id", tenantID, "new_vulns", newVulns)
}
